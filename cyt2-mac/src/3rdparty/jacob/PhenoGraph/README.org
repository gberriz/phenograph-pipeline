The function =LouvainfromBin= (in
=cyt2-mac/src/3rdparty/jacob/PhenoGraph/LouvainfromBin.m=) invokes
several external programs, and collects information from their
outputs.  These external programs are called =convert=, =community=,
and =hierarchy=, and their executables are all in the
=cyt2-mac/src/3rdparty/jacob/PhenoGraph/Louvain= directory.

As far as I can tell, the function LouvainfromBin is supposed to do
the following (in broad outline):

  1. invoke =convert= (which generates several output files);

  2. at each one of several iterations

     2.1 invoke =community= (with the output files generated by
         =convert= as arguments), and extract "modularity scores" for
         various "levels" from its stderr output;

     2.2 invoke =hierarchy= for each of several "levels", collecting
         its screen output (stdout and stderr);

  3. determine the iteration and level with the highest modularity score;

  4. return the collected modularity scores, hierarchy outputs, the
     "partition" for the best modularity score (=bestpartition=), and
     the "partition hierarchy" (=bestpartitionhierarchy=) for the best
     modularity score.

In reality, however, this not what happens, due to an off-by-one error.

In more detail, at each iteration,

  1. /N/ modularity scores, corresponding to levels labeled 0 through
     /N/ - 1, are extracted from =community='s output; these are
     stored in an array called =q=, with =q(k)= being the modularity
     score for level /k/ - 1;

  2. the variable num_levels gets initialized, as follows:

      #+begin_src matlab
    % below, the command variable holds a command of the form
    % `hierarchy G.tree`
    [~,r] = system( command );
    r = strtok(r, 10);
    r = regexprep( r, 'Number of levels: ', '' );
    num_levels = str2double( r )-1;
      #+end_src

     For example, if the output from =hierarchy G.tree= is

      #+begin_src
Number of levels: 5
level 0: 10000 nodes
level 1: 400 nodes
level 2: 41 nodes
level 3: 18 nodes
level 4: 17 nodes
      #+end_src

     ...then =num_levels= will be set to 4, not to 5, as the name of
     the variable would lead one to expect; in fact, =num_levels=
     holds the highest level number, since the levels are numbered
     starting with 0.

  3. then the following loop gets executed:

      #+begin_src matlab
    for level = 1:num_levels

        command = [ps 'hierarchy ' filename '.tree -l ' num2str( level ) ' > ' filename '.tmp' ];

        system( command );
        hierarchy_output = load( [filename '.tmp'] );
        c{iter,level} = hierarchy_output(:,2) + 1;
        Q{iter,level} = q(level);

    end
      #+end_src

     The off-by-one error occurs here.  For example the value assigned
     to =c{iter, 1}= comes from the output of =hierarchy= for level 1,
     but the value assigned to =Q{iter, 1}= is the modularity score
     for level 0.

     Note that the last element of =q=, whose index always equals
     =num_levels + 1=, never gets collected in =Q=.  As it happens,
     this left-out value is always the highest modularity score for
     the run.

     (Similarly, the =hierarchy= output for level 0 is never stored in
     the =c= variable, since the loop never executes a =hierarchy= run
     for this level.)

  4. the variables =bestpartition= and =bestpartitionhierarchy= are
     initialized through the code below

      #+begin_src matlab
maxmod = 0;
for i = 1:numel(Q)
    if Q{i} > maxmod
        maxmod = Q{i};
        [I,J] = ind2sub( size(Q), i );
    end
end
bestpartition = c{I,J};
bestpartitionhierarchy = c(I,:);
      #+end_src

     This loop identifies the indices =[I, J]= corresponding to the
     highest value in =Q=, and sets =bestpartition= and
     =bestpartitionhierarchy= to values in =c= corresponding to these
     indices.

     As noted earlier, this is wrong in two ways: first =Q= does not
     contain the highest modularity scores from the =community= runs
     (these scores were systematically kept out of =Q=); and second,
     in general, the modularity score for the content in =c{I, J}= is
     not the one stored in =Q{I, J}=; if it is stored in =Q= at all,
     it is at =Q{I, J+1}=.
